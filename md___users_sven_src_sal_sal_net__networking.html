<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sal: Networking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sal
   &#160;<span id="projectnumber">0.32.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md___users_sven_src_sal_sal_net__networking.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Networking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#overview">Overview </a><ul><li class="level2"><a href="#sync-mode">Synchronous operations </a></li>
<li class="level2"><a href="#async-mode">Asynchronous operations </a></li>
</ul>
</li>
<li class="level1"><a href="#error-handling">Error handling </a><ul><li class="level2"><a href="#error-handling-sync">Synchronous methods </a></li>
<li class="level2"><a href="#error-handing-async">Asynchronous methods </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="overview"></a>
Overview </h1>
<p><a class="el" href="namespacesal_1_1net.html" title="Networking primitives (sockets, resolver, etc) ">sal::net</a> module provides low-level networking services. Socket operations may be performed in synchronous or asynchonous manner. Here is the conceptual overview how different pieces work together.</p>
<h2><a class="anchor" id="sync-mode"></a>
Synchronous operations </h2>
<p>In synchronous API, sockets' API follows usual BSD API. <a class="el" href="md___users_sven_src_sal_sal_net__networking.html#error-handling">Error handling </a> is documented separately.</p>
<p>Example client side session: </p><div class="fragment"><div class="line"><span class="comment">// Connect to remote server that listens at server_endpoint</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html">sal::net::ip::tcp_t::socket_t</a> channel;</div><div class="line">channel.<a class="code" href="classsal_1_1net_1_1basic__socket__t.html#a77a646475c8df4b3adca40985a285e86">connect</a>(server_endpoint);</div><div class="line"></div><div class="line"><span class="comment">// Send data to server (&#39;hello\0&#39;)</span></div><div class="line"><span class="keyword">auto</span> sent_size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a2e5134cdc80b90b120927ad9218e0ad1">send</a>(<span class="stringliteral">&quot;hello&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Receive data from server (up to 1024B)</span></div><div class="line"><span class="keywordtype">char</span> data[1024];</div><div class="line"><span class="keyword">auto</span> received_size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#aeef449f9b3486e4162a011c019d6fe66">receive</a>(data);</div></div><!-- fragment --><p>Same session from server side: </p><div class="fragment"><div class="line"><span class="comment">// Listen for incoming connections at listen_endpoint</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1basic__socket__acceptor__t.html">sal::net::ip::tcp_t::acceptor_t</a> acceptor(listen_endpoint, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// Accept new incoming connection</span></div><div class="line"><span class="keyword">auto</span> channel = acceptor.accept();</div><div class="line"></div><div class="line"><span class="comment">// Echo data from client back to it</span></div><div class="line"><span class="keywordtype">char</span> data[1024];</div><div class="line"><span class="keyword">auto</span> size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#aeef449f9b3486e4162a011c019d6fe66">receive</a>(data);</div><div class="line">channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a2e5134cdc80b90b120927ad9218e0ad1">send</a>(sal::make_buf(data, size));</div></div><!-- fragment --><h2><a class="anchor" id="async-mode"></a>
Asynchronous operations </h2>
<p>For asynchronous API, there are multiple parts:</p><ul>
<li><a class="el" href="classsal_1_1net_1_1async_1_1service__t.html" title="Asynchronous networking I/O completion service. ">sal::net::async::service_t</a> wraps OS-specific proactor (IOCP) or reactor (epoll/kqueue) working together with <a class="el" href="classsal_1_1net_1_1async_1_1completion__queue__t.html" title="Asynchronous networking I/O completion queue. ">sal::net::async::completion_queue_t</a> to provide unified proactor API</li>
<li><a class="el" href="classsal_1_1net_1_1async_1_1completion__queue__t.html" title="Asynchronous networking I/O completion queue. ">sal::net::async::completion_queue_t</a> holds list of completed events and provides methods to poll for completed I/O operations</li>
<li><a class="el" href="classsal_1_1net_1_1async_1_1io__t.html" title="Asynchronous socket I/O operation handle and associated data for I/O (2kB). ">sal::net::async::io_t</a> represents single asynchronous operation and related I/O buffer (size above MTU size but below 2kB)</li>
</ul>
<p>There is usually one <a class="el" href="classsal_1_1net_1_1async_1_1service__t.html" title="Asynchronous networking I/O completion service. ">sal::net::async::service_t</a> instance per application. Each worker thread has own <a class="el" href="classsal_1_1net_1_1async_1_1completion__queue__t.html" title="Asynchronous networking I/O completion queue. ">sal::net::async::completion_queue_t</a> instance. To poll for completed asynchronous I/O operations, threads invoke periodically <a class="el" href="classsal_1_1net_1_1async_1_1completion__queue__t.html#ac7a2cc76dc8c9c534a3605ecbb9ad37d" title="Suspend calling thread until there are more I/O operations completed. ">sal::net::async::completion_queue_t::wait()</a> (or similar related methods) that suspends calling thread until more operations have completed and dispatched into queue. After that, threads can call repeatedly <a class="el" href="classsal_1_1net_1_1async_1_1completion__queue__t.html#a2f53bc4e3461363cd9dfcbd1b97cb815" title="Return next completed I/O operation without blocking calling thread. ">sal::net::async::completion_queue_t::try_get()</a> to extract those operations from queue.</p>
<p>To detect which operation finished, use <a class="el" href="classsal_1_1net_1_1async_1_1io__t.html#acd2dc91298c90e49a6b22e5d745f89cd">sal::net::async::io_t::get_if&lt;ResultType&gt;()</a> that returns pointer to result data or <code>nullptr</code> if completed operation is not ResultType. Possible ResultType types can be found in specific socket class as nested structs with name <code>OperationType_t</code> (for example, <a class="el" href="structsal_1_1net_1_1basic__datagram__socket__t_1_1receive__from__t.html" title="start_receive_from() result type. ">sal::net::basic_datagram_socket_t::receive_from_t</a>, etc).</p>
<p>Sample usage (pseudocode):</p>
<div class="fragment"><div class="line"><span class="comment">// global I/O completion service</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1async_1_1service__t.html">sal::net::async::service_t</a> io_svc;</div><div class="line"></div><div class="line"><span class="comment">// create socket and associate it with service to support asynchronous I/O</span></div><div class="line"><span class="keyword">using</span> socket_t = <a class="code" href="classsal_1_1net_1_1ip_1_1udp__t.html#abfa733097eec5321df2f2b29ee4b6648">sal::net::ip::udp_t::socket_t</a>;</div><div class="line">socket_t socket;</div><div class="line">socket.associate(io_svc);</div><div class="line"></div><div class="line"><span class="comment">// per worker thread completion queue</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1async_1_1completion__queue__t.html">sal::net::async::completion_queue_t</a> io_queue(io_svc);</div><div class="line"></div><div class="line"><span class="comment">// allocate asynchronous I/O handle (application becomes owner)</span></div><div class="line"><span class="comment">// Note: io_svc supports make_io() as well to allow starting I/O operations</span></div><div class="line"><span class="comment">// outside worker thread</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1async_1_1io__t.html">sal::net::async::io_t</a> io = io_queue.make_io();</div><div class="line"></div><div class="line"><span class="comment">// start asynchronous receive_from (OS, io_svc or io_queue becomes owner,</span></div><div class="line"><span class="comment">// depending whether I/O completed immediately or not)</span></div><div class="line">socket.start_receive_from(std::move(io));</div><div class="line"></div><div class="line"><span class="comment">// handle completions while not stopped</span></div><div class="line"><span class="keywordflow">while</span> (!stopped)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> io = io_queue.try_get())</div><div class="line">  {</div><div class="line">    <span class="comment">// application now owns io</span></div><div class="line"></div><div class="line">    <span class="comment">// detect and handle completed I/O</span></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> receive_from = io.<a class="code" href="classsal_1_1net_1_1async_1_1io__t.html#a30fe194f15fe6f023636ce35c31c31e8">get_if</a>&lt;socket_t::receive_from_t&gt;())</div><div class="line">    {</div><div class="line">      <span class="comment">// received data from receive_from-&gt;remote_endpoint</span></div><div class="line">      <span class="comment">// in [io.data(), io.data() + receive_from-&gt;transferred)</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> send_to = io.<a class="code" href="classsal_1_1net_1_1async_1_1io__t.html#a30fe194f15fe6f023636ce35c31c31e8">get_if</a>&lt;socket_t::send_to_t&gt;())</div><div class="line">    {</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// application still owns io. It can be reused for different operation. If</span></div><div class="line">    <span class="comment">// not reused, on leaving scope it is automatically released into pool</span></div><div class="line">    <span class="comment">// (io_svc becomes owner)</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="comment">// suspend thread until there are more completions to handle</span></div><div class="line">    <span class="comment">// (even if there are completed I/O operations in queue)</span></div><div class="line">    io_queue.wait();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="error-handling"></a>
Error handling </h1>
<h2><a class="anchor" id="error-handling-sync"></a>
Synchronous methods </h2>
<p>Each networking library synchronous method provide two overloads, one that throws an exception, and another that sets an <code>std::error_code&amp;</code> (last parameter). This supports common use cases:</p><ul>
<li>cases where system errors are truly exceptional and indicate serious failure. In this case, throwing an exception is the most appropriate response.</li>
<li>cases where syscall errors are routine and do not necessarily represent failure. Returning an error code in the most appropriate response. This allows application-specific error handling, including simply ignoring errors.</li>
</ul>
<p>Methods not having last argument <code>std::error_code&amp;</code> report errors as follows:</p><ul>
<li>when underlying calls result in error that prevents method succeeding, the method exists via an exception of type <code>std::system_error</code></li>
<li>destructors throw nothing</li>
</ul>
<p>Methods with last argument <code>std::error_code&amp;</code> report errors as follows:</p><ul>
<li>when underlying calls result in error that prevents method succeeding, the method sets passed error variable reference to result error and exits immediately. Otherwise, returned error is set such that <code>!error</code> is <code>true</code>.</li>
</ul>
<h2><a class="anchor" id="error-handing-async"></a>
Asynchronous methods </h2>
<p>In asynchronous invocations, errors are not returned/thrown immediately (even if detected) but during operation result handling. This simplifies application's completions and errors handling.</p>
<p>Error handling is similar to <a class="el" href="md___users_sven_src_sal_sal_net__networking.html#error-handling-sync">Synchronous methods </a> except error code is returned during operation type detection call. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
