<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sal: Networking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sal
   &#160;<span id="projectnumber">0.31.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md___users_sven_src_sal_sal_net__networking.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Networking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#overview">Overview </a><ul><li class="level2"><a href="#sync-mode">Synchronous operations </a></li>
<li class="level2"><a href="#async-mode">Asynchronous operations </a></li>
</ul>
</li>
<li class="level1"><a href="#error-handling">Error handling </a><ul><li class="level2"><a href="#error-handling-sync">Synchronous methods </a></li>
<li class="level2"><a href="#error-handing-async">Asynchronous methods </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="overview"></a>
Overview </h1>
<p><a class="el" href="namespacesal_1_1net.html" title="Networking primitives (sockets, resolver, etc) ">sal::net</a> module provides low-level networking services. Socket operations may be performed in synchronous or asynchonous manner. Here is the conceptual overview how different pieces work together.</p>
<h2><a class="anchor" id="sync-mode"></a>
Synchronous operations </h2>
<p>In synchronous API, sockets' API follows usual BSD API. <a class="el" href="md___users_sven_src_sal_sal_net__networking.html#error-handling">Error handling </a> is documented separately.</p>
<p>Example client side session: </p><div class="fragment"><div class="line"><span class="comment">// Connect to remote server that listens at server_endpoint</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html">sal::net::ip::tcp_t::socket_t</a> channel;</div><div class="line">channel.<a class="code" href="classsal_1_1net_1_1basic__socket__t.html#a77a646475c8df4b3adca40985a285e86">connect</a>(server_endpoint);</div><div class="line"></div><div class="line"><span class="comment">// Send data to server (&#39;hello\0&#39;)</span></div><div class="line"><span class="keyword">auto</span> sent_size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a2e5134cdc80b90b120927ad9218e0ad1">send</a>(<span class="stringliteral">&quot;hello&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Receive data from server (up to 1024B)</span></div><div class="line"><span class="keywordtype">char</span> data[1024];</div><div class="line"><span class="keyword">auto</span> received_size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#aeef449f9b3486e4162a011c019d6fe66">receive</a>(data);</div></div><!-- fragment --><p>Same session from server side: </p><div class="fragment"><div class="line"><span class="comment">// Listen for incoming connections at listen_endpoint</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1basic__socket__acceptor__t.html">sal::net::ip::tcp_t::acceptor_t</a> acceptor(listen_endpoint, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// Accept new incoming connection</span></div><div class="line"><span class="keyword">auto</span> channel = acceptor.accept();</div><div class="line"></div><div class="line"><span class="comment">// Echo data from client back to it</span></div><div class="line"><span class="keywordtype">char</span> data[1024];</div><div class="line"><span class="keyword">auto</span> size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#aeef449f9b3486e4162a011c019d6fe66">receive</a>(data);</div><div class="line">channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a2e5134cdc80b90b120927ad9218e0ad1">send</a>(sal::make_buf(data, size));</div></div><!-- fragment --><h2><a class="anchor" id="async-mode"></a>
Asynchronous operations </h2>
<p>For asynchronous API, there are multiple parts working together:</p><ul>
<li><a class="el" href="classsal_1_1net_1_1async_1_1service__t.html" title="Asynchronous networking I/O completion service. ">sal::net::async::service_t</a> wraps OS-specific proactor (IOCP) or reactor (epoll/kqueue) into unified proactor-based class</li>
<li><a class="el" href="classsal_1_1net_1_1async_1_1io__t.html" title="Asynchronous socket I/O operation handle and associated data for I/O (2kB). ">sal::net::async::io_t</a> represents single asynchronous operation and related I/O buffer (size above MTU size but below 2kB)</li>
</ul>
<p>There is usually one <a class="el" href="classsal_1_1net_1_1async_1_1service__t.html" title="Asynchronous networking I/O completion service. ">sal::net::async::service_t</a> instance per application. Each worker thread that wants to receive I/O completion notifications, does it by invoking repeatedly <a class="el" href="classsal_1_1net_1_1async_1_1service__t.html#a8023a195376d3d8f0e4c891a0b67a95e" title="Return next completed I/O operation. ">sal::net::async::service_t::poll()</a> (or similar related methods). This method returns one completed operation or if returned object bool cast returns false, there is none. This instance is generic completed asynchronous opoerations. To detect which operation exactly finished, use <a class="el" href="classsal_1_1net_1_1async_1_1io__t.html#acd2dc91298c90e49a6b22e5d745f89cd">sal::net::async::io_t::get_if&lt;ResultType&gt;()</a> that returns pointer to result data or <code>nullptr</code> if completed operation is not ResultType. Possible ResultType types can be found in specific socket class as nested structs with name <code>OperationType_t</code> (for example, <a class="el" href="structsal_1_1net_1_1basic__datagram__socket__t_1_1receive__from__t.html" title="receive_from_async() result type. ">sal::net::basic_datagram_socket_t::receive_from_t</a>, etc).</p>
<p>Sample usage (pseudocode):</p>
<div class="fragment"><div class="line"><span class="comment">// global I/O completion poller</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1async_1_1service__t.html">sal::net::async::service_t</a> io_svc;</div><div class="line"></div><div class="line"><span class="comment">// create socket and associate it with service to support asynchronous I/O</span></div><div class="line"><span class="keyword">using</span> socket_t = <a class="code" href="classsal_1_1net_1_1ip_1_1udp__t.html#abfa733097eec5321df2f2b29ee4b6648">sal::net::ip::udp_t::socket_t</a>;</div><div class="line">socket_t socket;</div><div class="line">socket.associate(io_svc);</div><div class="line"></div><div class="line"><span class="comment">// allocate asynchronous I/O handle (application is owner)</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1async_1_1io__t.html">sal::net::async::io_t</a> io = io_svc.<a class="code" href="classsal_1_1net_1_1async_1_1service__t.html#a67a147732a8e0c0af0a908d805884401">make_io</a>();</div><div class="line"></div><div class="line"><span class="comment">// start asynchronous recvfrom (io_svc is owner)</span></div><div class="line">socket.receive_from_async(std::move(io));</div><div class="line"></div><div class="line"><span class="comment">// handle completions while not stopped</span></div><div class="line"><span class="keywordflow">while</span> (!stopped)</div><div class="line">{</div><div class="line">  <span class="comment">// block until thre are completions to handle</span></div><div class="line">  <span class="comment">// (or if any operation is already completed, return immediately)</span></div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> io = io_svc.<a class="code" href="classsal_1_1net_1_1async_1_1service__t.html#a428da8b0b885a708732b76d98969677d">poll</a>())</div><div class="line">  {</div><div class="line">    <span class="comment">// application owns io</span></div><div class="line"></div><div class="line">    <span class="comment">// detect and handle completed I/O type</span></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> result = io.<a class="code" href="classsal_1_1net_1_1async_1_1io__t.html#a30fe194f15fe6f023636ce35c31c31e8">get_if</a>&lt;socket_t::receive_from_t&gt;())</div><div class="line">    {</div><div class="line">      <span class="comment">// received data from result-&gt;remote_endpoint</span></div><div class="line">      <span class="comment">// in [io.data(), io.data() + result-&gt;transferred)</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">auto</span> result = io.<a class="code" href="classsal_1_1net_1_1async_1_1io__t.html#a30fe194f15fe6f023636ce35c31c31e8">get_if</a>&lt;socket_t::send_to_t&gt;())</div><div class="line">    {</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// application owns io. It can be reused for different operation. If not</span></div><div class="line">    <span class="comment">// reused, on leaving scope it is automatically released into pool (io_svc</span></div><div class="line">    <span class="comment">// becomes owner)</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="error-handling"></a>
Error handling </h1>
<h2><a class="anchor" id="error-handling-sync"></a>
Synchronous methods </h2>
<p>Each networking library synchronous method provide two overloads, one that throws an exception, and another that sets an <code>std::error_code&amp;</code> (last parameter). This supports common use cases:</p><ul>
<li>cases where system errors are truly exceptional and indicate serious failure. In this case, throwing an exception is the most appropriate response.</li>
<li>cases where syscall errors are routine and do not necessarily represent failure. Returning an error code in the most appropriate response. This allows application-specific error handling, including simply ignoring errors.</li>
</ul>
<p>Methods not having last argument <code>std::error_code&amp;</code> report errors as follows:</p><ul>
<li>when underlying calls result in error that prevents method succeeding, the method exists via an exception of type <code>std::system_error</code></li>
<li>destructors throw nothing</li>
</ul>
<p>Methods with last argument <code>std::error_code&amp;</code> report errors as follows:</p><ul>
<li>when underlying calls result in error that prevents method succeeding, the method sets passed error variable reference to result error and exits immediately. Otherwise, returned error is set such that <code>!error</code> is <code>true</code>.</li>
</ul>
<h2><a class="anchor" id="error-handing-async"></a>
Asynchronous methods </h2>
<p>In asynchronous invocations, errors are not returned/thrown immediately (even if detected) but during operation result handling. This simplifies application's completions and errors handling.</p>
<p>Error handling is similar to <a class="el" href="md___users_sven_src_sal_sal_net__networking.html#error-handling-sync">Synchronous methods </a> except error code is returned during operation type detection call. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
