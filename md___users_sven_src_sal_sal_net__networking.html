<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sal: Networking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sal
   &#160;<span id="projectnumber">0.19.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md___users_sven_src_sal_sal_net__networking.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Networking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#overview">Overview </a><ul><li class="level2"><a href="#sync-mode">Synchronous operations </a></li>
<li class="level2"><a href="#async-mode">Asynchronous operations </a></li>
</ul>
</li>
<li class="level1"><a href="#error-handling">Error handling </a><ul><li class="level2"><a href="#error-handling-sync">Synchronous methods </a></li>
<li class="level2"><a href="#error-handing-async">Asynchronous methods </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="overview"></a>
Overview </h1>
<p><a class="el" href="namespacesal_1_1net.html" title="Networking primitives (sockets, resolver, etc) ">sal::net</a> module provides low-level networking services. Socket operations may be performed in synchronous or asynchonous manner. Here is the conceptual overview how different pieces work together.</p>
<h2><a class="anchor" id="sync-mode"></a>
Synchronous operations </h2>
<p>In synchronous API, sockets' API follows usual BSD API. <a class="el" href="md___users_sven_src_sal_sal_net__networking.html#error-handling">Error handling </a> is documented separately.</p>
<p>Example client side session: </p><div class="fragment"><div class="line"><span class="comment">// Connect to remote server that listens at server_endpoint</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html">sal::net::ip::tcp_t::socket_t</a> channel;</div><div class="line">channel.<a class="code" href="classsal_1_1net_1_1basic__socket__t.html#a77a646475c8df4b3adca40985a285e86">connect</a>(server_endpoint);</div><div class="line"></div><div class="line"><span class="comment">// Send data to server (&#39;hello\0&#39;)</span></div><div class="line"><span class="keyword">auto</span> sent_size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a2b7d511f271445082a3a86f3e10542b5">send</a>(sal::make_buf(<span class="stringliteral">&quot;hello&quot;</span>));</div><div class="line"></div><div class="line"><span class="comment">// Receive data from server (up to 1024B)</span></div><div class="line"><span class="keywordtype">char</span> data[1024];</div><div class="line"><span class="keyword">auto</span> received_size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a43d75de6c4f2cced7d4140fe6573dd05">receive</a>(sal::make_buf(data));</div></div><!-- fragment --><p>Same session from server side: </p><div class="fragment"><div class="line"><span class="comment">// Listen for incoming connections at listen_endpoint</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1basic__socket__acceptor__t.html">sal::net::ip::tcp_t::acceptor_t</a> acceptor(listen_endpoint, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// Accept new incoming connection</span></div><div class="line"><span class="keyword">auto</span> channel = acceptor.accept();</div><div class="line"></div><div class="line"><span class="comment">// Echo data from client back to it</span></div><div class="line"><span class="keywordtype">char</span> data[1024];</div><div class="line"><span class="keyword">auto</span> size = channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a43d75de6c4f2cced7d4140fe6573dd05">receive</a>(sal::make_buf(data));</div><div class="line">channel.<a class="code" href="classsal_1_1net_1_1basic__stream__socket__t.html#a2b7d511f271445082a3a86f3e10542b5">send</a>(sal::make_buf(data, size));</div></div><!-- fragment --><h2><a class="anchor" id="async-mode"></a>
Asynchronous operations </h2>
<p>For asynchronous API, there are multiple parts working together:</p><ul>
<li><a class="el" href="classsal_1_1net_1_1async__service__t.html" title="Asynchronous networking I/O completion service. ">sal::net::async_service_t</a> provides internal OS-specific underlying functionality (IOCP/epoll/kqueue handle, used by <a class="el" href="classsal_1_1net_1_1async__service__t_1_1context__t.html" title="Per I/O thread representative of async_service_t. ">sal::net::async_service_t::context_t</a>, not application directly).</li>
<li><a class="el" href="classsal_1_1net_1_1async__service__t_1_1context__t.html" title="Per I/O thread representative of async_service_t. ">sal::net::async_service_t::context_t</a> maintains thread-specific resources and forwards asynchronous calls completions to application domain</li>
<li><a class="el" href="classsal_1_1net_1_1async__service__t_1_1io__t.html" title="Asynchronous socket I/O operation handle and associated data for I/O (4kB). ">sal::net::async_service_t::io_t</a> represents single asynchronous operations and related resources.</li>
</ul>
<p>There is usually one <a class="el" href="classsal_1_1net_1_1async__service__t.html" title="Asynchronous networking I/O completion service. ">sal::net::async_service_t</a> per application. Each thread that invokes callbacks from OS to application, does it by invoking repeatedly method <a class="el" href="classsal_1_1net_1_1async__service__t_1_1context__t.html#adab2eccf3feaa45b509dcdcd7a2d60e8" title="Return completed I/O operation handle for asynchronous operation. ">sal::net::async_service_t::context_t::poll</a> that returns one completed operation or <code>nullptr</code> if there is none. Returned <a class="el" href="namespacesal_1_1net.html#a2c1f2af17310f6dedab57469454ce03e" title="Strict ownership pointer to asynchronous I/O operation handle. ">sal::net::io_ptr</a> (std::unique_ptr to <a class="el" href="classsal_1_1net_1_1async__service__t_1_1io__t.html" title="Asynchronous socket I/O operation handle and associated data for I/O (4kB). ">sal::net::async_service_t::io_t</a>) is generic completed asynchronous operation. To detect which exactly, call <code>SOCKET_TYPE::async_OPERATION_result</code>. If buffer represents given operation, pointer to result data is returned or <code>nullptr</code> otherwise.</p>
<p>Sample usage (pseudocode): </p><div class="fragment"><div class="line"><span class="comment">// global I/O service</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1async__service__t.html">sal::net::async_service_t</a> svc;</div><div class="line"></div><div class="line"><span class="comment">// for each thread</span></div><div class="line"><a class="code" href="classsal_1_1net_1_1async__service__t_1_1context__t.html">sal::net::async_service_t::context_t</a> ctx = svc.<a class="code" href="classsal_1_1net_1_1async__service__t.html#a0add42a97668d41b423bd62f68366b45">make_context</a>();</div><div class="line"></div><div class="line"><span class="comment">// create channel associated with async service</span></div><div class="line"><span class="keyword">using</span> socket_t = <a class="code" href="classsal_1_1net_1_1ip_1_1udp__t.html#abfa733097eec5321df2f2b29ee4b6648">sal::net::ip::udp_t::socket_t</a>;</div><div class="line">socket_t channel;</div><div class="line">channel.<a class="code" href="classsal_1_1net_1_1basic__socket__t.html#a2ade4ad82c3bbe02a0267b842169b6e7">associate</a>(svc);</div><div class="line"></div><div class="line"><span class="comment">// allocate asynchronous operation handle (application owns io)</span></div><div class="line"><a class="code" href="namespacesal_1_1net.html#a2c1f2af17310f6dedab57469454ce03e">sal::net::io_ptr</a> io = ctx.<a class="code" href="classsal_1_1net_1_1async__service__t_1_1context__t.html#a5d21eb6881529b80cada677e46341a26">make_io</a>();</div><div class="line"></div><div class="line"><span class="comment">// start asynchronous receive_from (networking library owns io)</span></div><div class="line">channel.async_receive_from(std::move(io));</div><div class="line"></div><div class="line"><span class="comment">// handle completions while not stopped</span></div><div class="line"><span class="keywordflow">while</span> (!stopped)</div><div class="line">{</div><div class="line">  <span class="comment">// block and wait until there are completions to handle</span></div><div class="line">  <span class="comment">// (if some operation has already completed, returns immediately)</span></div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> io = ctx.<a class="code" href="classsal_1_1net_1_1async__service__t_1_1context__t.html#adab2eccf3feaa45b509dcdcd7a2d60e8">poll</a>())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> *result = socket_t::async_receive_from_result(io))</div><div class="line">    {</div><div class="line">      <span class="comment">// handle completed receive from, result provides information about it</span></div><div class="line">    }</div><div class="line">    <span class="comment">// else: list other operations&#39; result handlers</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// application owns io: it can be reused or simply dropped, in which</span></div><div class="line">  <span class="comment">// case ctx will automatically return it to internal free list</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="error-handling"></a>
Error handling </h1>
<h2><a class="anchor" id="error-handling-sync"></a>
Synchronous methods </h2>
<p>Each networking library synchronous method provide two overloads, one that throws an exception, and another that sets an <code>std::error_code&amp;</code> (last parameter). This supports common use cases:</p><ul>
<li>cases where system errors are truly exceptional and indicate serious failure. In this case, throwing an exception is the most appropriate response.</li>
<li>cases where syscall errors are routine and do not necessarily represent failure. Returning an error code in the most appropriate response. This allows application-specific error handling, including simply ignoring errors.</li>
</ul>
<p>Methods not having last argument <code>std::error_code&amp;</code> report errors as follows:</p><ul>
<li>when underlying calls result in error that prevents method succeeding, the method exists via an exception of type <code>std::system_error</code></li>
<li>destructors throw nothing</li>
</ul>
<p>Methods with last argument <code>std::error_code&amp;</code> report errors as follows:</p><ul>
<li>when underlying calls result in error that prevents method succeeding, the method sets passed error variable reference to result error and exits immediately. Otherwise, returned error is set such that <code>!error</code> is <code>true</code>.</li>
</ul>
<h2><a class="anchor" id="error-handing-async"></a>
Asynchronous methods </h2>
<p>In asynchronous invocations, errors are not returned/thrown immediately (even if detected) but during operation result handling. This simplifies application's completions and errors handling.</p>
<p>Error handling is similar to <a class="el" href="md___users_sven_src_sal_sal_net__networking.html#error-handling-sync">Synchronous methods </a> except error code is returned during operation type detection call. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
