<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sal: sal::memory_writer_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sal
   &#160;<span id="projectnumber">0.23.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classsal_1_1memory__writer__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsal_1_1memory__writer__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sal::memory_writer_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper class for memory range [pair.first, pair.second).  
 <a href="classsal_1_1memory__writer__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory__writer_8hpp_source.html">memory_writer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sal::memory_writer_t:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsal_1_1memory__writer__t.png" usemap="#sal::memory_5Fwriter_5Ft_map" alt=""/>
  <map id="sal::memory_5Fwriter_5Ft_map" name="sal::memory_5Fwriter_5Ft_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74f20307436efdd86d9d9567ddbf2577"><td class="memItemLeft" align="right" valign="top"><a id="a74f20307436efdd86d9d9567ddbf2577"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>memory_writer_t</b> (const <a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;)=delete</td></tr>
<tr class="separator:a74f20307436efdd86d9d9567ddbf2577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416d0138ad734445feedf74549789944"><td class="memItemLeft" align="right" valign="top"><a id="a416d0138ad734445feedf74549789944"></a>
<a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;)=delete</td></tr>
<tr class="separator:a416d0138ad734445feedf74549789944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba5501acb9cc33021601fd06bbfeff7"><td class="memTemplParams" colspan="2"><a id="a0ba5501acb9cc33021601fd06bbfeff7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ba5501acb9cc33021601fd06bbfeff7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a0ba5501acb9cc33021601fd06bbfeff7">memory_writer_t</a> (T *<a class="el" href="classsal_1_1memory__writer__t.html#a0ebce41b441505bee87ca1eaa3aff1be">begin</a>, const T *<a class="el" href="classsal_1_1memory__writer__t.html#ac0481edfdc6a6a1bb4a35721aa6d40e1">end</a>) noexcept</td></tr>
<tr class="memdesc:a0ba5501acb9cc33021601fd06bbfeff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct memory writer using range [begin, end) <br /></td></tr>
<tr class="separator:a0ba5501acb9cc33021601fd06bbfeff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92749a6a78f3ae53198f2f96044bd92a"><td class="memTemplParams" colspan="2"><a id="a92749a6a78f3ae53198f2f96044bd92a"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a92749a6a78f3ae53198f2f96044bd92a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a92749a6a78f3ae53198f2f96044bd92a">memory_writer_t</a> (T(&amp;array)[N]) noexcept</td></tr>
<tr class="memdesc:a92749a6a78f3ae53198f2f96044bd92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct memory writer using range [array, array + N) <br /></td></tr>
<tr class="separator:a92749a6a78f3ae53198f2f96044bd92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9e2748e1212254400b79b7458487a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#acd9e2748e1212254400b79b7458487a1">memory_writer_t</a> (<a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&amp;that) noexcept</td></tr>
<tr class="memdesc:acd9e2748e1212254400b79b7458487a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct memory writer from <em>that</em>.  <a href="#acd9e2748e1212254400b79b7458487a1">More...</a><br /></td></tr>
<tr class="separator:acd9e2748e1212254400b79b7458487a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecd0069e7f35104d540e86db09f9386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a6ecd0069e7f35104d540e86db09f9386">operator=</a> (<a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&amp;that) noexcept</td></tr>
<tr class="memdesc:a6ecd0069e7f35104d540e86db09f9386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <em>this</em> using range from <em>that</em>.  <a href="#a6ecd0069e7f35104d540e86db09f9386">More...</a><br /></td></tr>
<tr class="separator:a6ecd0069e7f35104d540e86db09f9386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863afae3195fee65c8442105ccea9e24"><td class="memItemLeft" align="right" valign="top"><a id="a863afae3195fee65c8442105ccea9e24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a863afae3195fee65c8442105ccea9e24">swap</a> (<a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;that) noexcept</td></tr>
<tr class="memdesc:a863afae3195fee65c8442105ccea9e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap range of <em>this</em> with <em>that</em>. <br /></td></tr>
<tr class="separator:a863afae3195fee65c8442105ccea9e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9e00bc9e357effc8dba9bdec6d362d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#afc9e00bc9e357effc8dba9bdec6d362d">good</a> () const noexcept</td></tr>
<tr class="memdesc:afc9e00bc9e357effc8dba9bdec6d362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if write pointer is less or equal to end pointer.  <a href="#afc9e00bc9e357effc8dba9bdec6d362d">More...</a><br /></td></tr>
<tr class="separator:afc9e00bc9e357effc8dba9bdec6d362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af459ca71248367d6eced48a727041ca9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#af459ca71248367d6eced48a727041ca9">operator bool</a> () const noexcept</td></tr>
<tr class="separator:af459ca71248367d6eced48a727041ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435afa3f70f9f9378d95a2973e61e432"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a435afa3f70f9f9378d95a2973e61e432">bad</a> () const noexcept</td></tr>
<tr class="memdesc:a435afa3f70f9f9378d95a2973e61e432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if write pointer has moved past upper limit.  <a href="#a435afa3f70f9f9378d95a2973e61e432">More...</a><br /></td></tr>
<tr class="separator:a435afa3f70f9f9378d95a2973e61e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab36d0cc679b1ad38b4aca2fc9816ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a5ab36d0cc679b1ad38b4aca2fc9816ed">full</a> () const noexcept</td></tr>
<tr class="memdesc:a5ab36d0cc679b1ad38b4aca2fc9816ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if write pointer has reached upper limit.  <a href="#a5ab36d0cc679b1ad38b4aca2fc9816ed">More...</a><br /></td></tr>
<tr class="separator:a5ab36d0cc679b1ad38b4aca2fc9816ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa39a54d7f8072ca946f59e9015614"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a86aa39a54d7f8072ca946f59e9015614">size</a> () const noexcept</td></tr>
<tr class="memdesc:a86aa39a54d7f8072ca946f59e9015614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes between writer pointer and upper limit.  <a href="#a86aa39a54d7f8072ca946f59e9015614">More...</a><br /></td></tr>
<tr class="separator:a86aa39a54d7f8072ca946f59e9015614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add643e53924452e1dd0ef3bd22075053"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#add643e53924452e1dd0ef3bd22075053">safe_size</a> () const noexcept</td></tr>
<tr class="memdesc:add643e53924452e1dd0ef3bd22075053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes between writer pointer and upper limit.  <a href="#add643e53924452e1dd0ef3bd22075053">More...</a><br /></td></tr>
<tr class="separator:add643e53924452e1dd0ef3bd22075053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebce41b441505bee87ca1eaa3aff1be"><td class="memItemLeft" align="right" valign="top"><a id="a0ebce41b441505bee87ca1eaa3aff1be"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a0ebce41b441505bee87ca1eaa3aff1be">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a0ebce41b441505bee87ca1eaa3aff1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current write pointer. <br /></td></tr>
<tr class="separator:a0ebce41b441505bee87ca1eaa3aff1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0481edfdc6a6a1bb4a35721aa6d40e1"><td class="memItemLeft" align="right" valign="top"><a id="ac0481edfdc6a6a1bb4a35721aa6d40e1"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#ac0481edfdc6a6a1bb4a35721aa6d40e1">end</a> () const noexcept</td></tr>
<tr class="memdesc:ac0481edfdc6a6a1bb4a35721aa6d40e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return upper limit pointer (one byte past actual fillable memory area) <br /></td></tr>
<tr class="separator:ac0481edfdc6a6a1bb4a35721aa6d40e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd861760533f8e8f919b7936dc5646d"><td class="memItemLeft" align="right" valign="top"><a id="a5bd861760533f8e8f919b7936dc5646d"></a>
<a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a5bd861760533f8e8f919b7936dc5646d">skip</a> (size_t n) noexcept</td></tr>
<tr class="memdesc:a5bd861760533f8e8f919b7936dc5646d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move write pointer towards upper limit <em>n</em> bytes without adding any new content. <br /></td></tr>
<tr class="separator:a5bd861760533f8e8f919b7936dc5646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d043e291505ccb4416a47cc8b09deb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a7d043e291505ccb4416a47cc8b09deb9">skip_until</a> (char ch) noexcept</td></tr>
<tr class="memdesc:a7d043e291505ccb4416a47cc8b09deb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move write pointer towards upper limit until character <em>ch</em> is found.  <a href="#a7d043e291505ccb4416a47cc8b09deb9">More...</a><br /></td></tr>
<tr class="separator:a7d043e291505ccb4416a47cc8b09deb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fba5b3bc60e76d5215ffcec407d2a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94fba5b3bc60e76d5215ffcec407d2a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a94fba5b3bc60e76d5215ffcec407d2a2">write</a> (T v) noexcept</td></tr>
<tr class="memdesc:a94fba5b3bc60e76d5215ffcec407d2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory content of <em>v</em> to <em>this</em> memory writer area and move write pointer towards upper limit by <code>sizeof(v)</code>.  <a href="#a94fba5b3bc60e76d5215ffcec407d2a2">More...</a><br /></td></tr>
<tr class="separator:a94fba5b3bc60e76d5215ffcec407d2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af46b74477ba689ca7eeed97078a7ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3af46b74477ba689ca7eeed97078a7ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a3af46b74477ba689ca7eeed97078a7ff">write</a> (const T *<a class="el" href="classsal_1_1memory__writer__t.html#a0ebce41b441505bee87ca1eaa3aff1be">begin</a>, const T *<a class="el" href="classsal_1_1memory__writer__t.html#ac0481edfdc6a6a1bb4a35721aa6d40e1">end</a>) noexcept</td></tr>
<tr class="memdesc:a3af46b74477ba689ca7eeed97078a7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory content of continuous memory area [<em>begin</em>, <em>end</em>) to <em>this</em> memory writer area and move write pointer towards upper limit by number of bytes between specified range.  <a href="#a3af46b74477ba689ca7eeed97078a7ff">More...</a><br /></td></tr>
<tr class="separator:a3af46b74477ba689ca7eeed97078a7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14a85578dbfb8ea5a6919ecf9be9ad8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:af14a85578dbfb8ea5a6919ecf9be9ad8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#af14a85578dbfb8ea5a6919ecf9be9ad8">write</a> (const T(&amp;array)[N]) noexcept</td></tr>
<tr class="memdesc:af14a85578dbfb8ea5a6919ecf9be9ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write [<em>array</em>, <em>array</em> + <em>N</em>) to <em>this</em> memory area.  <a href="#af14a85578dbfb8ea5a6919ecf9be9ad8">More...</a><br /></td></tr>
<tr class="separator:af14a85578dbfb8ea5a6919ecf9be9ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69298c3801bf229b75b2d86a9cfa1f60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a69298c3801bf229b75b2d86a9cfa1f60">operator&lt;&lt;</a> (const char *value) noexcept</td></tr>
<tr class="memdesc:a69298c3801bf229b75b2d86a9cfa1f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy NUL-terminated string content to this memory area.  <a href="#a69298c3801bf229b75b2d86a9cfa1f60">More...</a><br /></td></tr>
<tr class="separator:a69298c3801bf229b75b2d86a9cfa1f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6597d676ebbe2888866967c7cfaba19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a6597d676ebbe2888866967c7cfaba19f">operator&lt;&lt;</a> (char value) noexcept</td></tr>
<tr class="memdesc:a6597d676ebbe2888866967c7cfaba19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert single character and advance write pointer.  <a href="#a6597d676ebbe2888866967c7cfaba19f">More...</a><br /></td></tr>
<tr class="separator:a6597d676ebbe2888866967c7cfaba19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffcd3acb17ff3d8dd940b897dab593d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a6ffcd3acb17ff3d8dd940b897dab593d">operator&lt;&lt;</a> (unsigned char value) noexcept</td></tr>
<tr class="separator:a6ffcd3acb17ff3d8dd940b897dab593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118243e0514fa0c1a989950860481868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#a118243e0514fa0c1a989950860481868">operator&lt;&lt;</a> (signed char value) noexcept</td></tr>
<tr class="separator:a118243e0514fa0c1a989950860481868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3ba49ab1c2264331c23f8a44789cc6"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename... Args&gt; </td></tr>
<tr class="memitem:abf3ba49ab1c2264331c23f8a44789cc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsal_1_1memory__writer__t.html#abf3ba49ab1c2264331c23f8a44789cc6">print</a> (Arg &amp;&amp;arg, Args &amp;&amp;...args) noexcept</td></tr>
<tr class="memdesc:abf3ba49ab1c2264331c23f8a44789cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each argument, invoke <a class="el" href="classsal_1_1memory__writer__t.html#a69298c3801bf229b75b2d86a9cfa1f60" title="Copy NUL-terminated string content to this memory area. ">operator&lt;&lt;()</a> ie add formatted content to <em>this</em>.  <a href="#abf3ba49ab1c2264331c23f8a44789cc6">More...</a><br /></td></tr>
<tr class="separator:abf3ba49ab1c2264331c23f8a44789cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrapper class for memory range [pair.first, pair.second). </p>
<p>It provides methods to fill specified range with unformatted content. There are also free functions (operator&lt;&lt;) to fill range with formatted content.</p>
<p>During instance creation, memory range is specified: first is write pointer where additional content is written and second is upper limit pointer. While filling content, write pointer is moved towards upper limit (i.e. no original beginning is remembered). When write pointer reaches upper limit, no more content will be actually copied but pointer is still moved forward. In such situation, object state becomes <a class="el" href="classsal_1_1memory__writer__t.html#a435afa3f70f9f9378d95a2973e61e432" title="Return true if write pointer has moved past upper limit. ">bad()</a> and <a class="el" href="classsal_1_1memory__writer__t.html#a86aa39a54d7f8072ca946f59e9015614" title="Return number of bytes between writer pointer and upper limit. ">size()</a> method return value is undefined. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acd9e2748e1212254400b79b7458487a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9e2748e1212254400b79b7458487a1">&#9670;&nbsp;</a></span>memory_writer_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal::memory_writer_t::memory_writer_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct memory writer from <em>that</em>. </p>
<p>Source object is not invalidated but using it in parallel with <em>this</em> is undefined behaviour. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a435afa3f70f9f9378d95a2973e61e432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435afa3f70f9f9378d95a2973e61e432">&#9670;&nbsp;</a></span>bad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sal::memory_writer_t::bad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if write pointer has moved past upper limit. </p>
<p>While object is in <a class="el" href="classsal_1_1memory__writer__t.html#a435afa3f70f9f9378d95a2973e61e432" title="Return true if write pointer has moved past upper limit. ">bad()</a> state, <a class="el" href="classsal_1_1memory__writer__t.html#a94fba5b3bc60e76d5215ffcec407d2a2" title="Copy memory content of v to this memory writer area and move write pointer towards upper limit by siz...">write()</a> methods update write pointer but do not actually add any new content. </p>

</div>
</div>
<a id="a5ab36d0cc679b1ad38b4aca2fc9816ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab36d0cc679b1ad38b4aca2fc9816ed">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sal::memory_writer_t::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if write pointer has reached upper limit. </p>
<p>If write pointer has moved past upper limit is considered as <a class="el" href="classsal_1_1memory__writer__t.html#a435afa3f70f9f9378d95a2973e61e432" title="Return true if write pointer has moved past upper limit. ">bad()</a> state instead of <a class="el" href="classsal_1_1memory__writer__t.html#a5ab36d0cc679b1ad38b4aca2fc9816ed" title="Return true if write pointer has reached upper limit. ">full()</a>. </p>

</div>
</div>
<a id="afc9e00bc9e357effc8dba9bdec6d362d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9e00bc9e357effc8dba9bdec6d362d">&#9670;&nbsp;</a></span>good()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sal::memory_writer_t::good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if write pointer is less or equal to end pointer. </p>
<p>Writer pointer being equal to upper limit is considered valid state as well because whole range is still valid. </p>

</div>
</div>
<a id="af459ca71248367d6eced48a727041ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af459ca71248367d6eced48a727041ca9">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sal::memory_writer_t::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsal_1_1memory__writer__t.html#afc9e00bc9e357effc8dba9bdec6d362d" title="Return true if write pointer is less or equal to end pointer. ">good()</a> </dd></dl>

</div>
</div>
<a id="a69298c3801bf229b75b2d86a9cfa1f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69298c3801bf229b75b2d86a9cfa1f60">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy NUL-terminated string content to this memory area. </p>
<p>When upper limit is reached, no content is copied but write pointer is still moved forward. </p>

</div>
</div>
<a id="a6597d676ebbe2888866967c7cfaba19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6597d676ebbe2888866967c7cfaba19f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert single character and advance write pointer. </p>
<p>When upper limit is reached, no content is copied but write pointer is still moved forward. </p>

</div>
</div>
<a id="a6ffcd3acb17ff3d8dd940b897dab593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffcd3acb17ff3d8dd940b897dab593d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsal_1_1memory__writer__t.html#a6597d676ebbe2888866967c7cfaba19f" title="Insert single character and advance write pointer. ">operator&lt;&lt;(char)</a> </dd></dl>

</div>
</div>
<a id="a118243e0514fa0c1a989950860481868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118243e0514fa0c1a989950860481868">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsal_1_1memory__writer__t.html#a6597d676ebbe2888866967c7cfaba19f" title="Insert single character and advance write pointer. ">operator&lt;&lt;(char)</a> </dd></dl>

</div>
</div>
<a id="a6ecd0069e7f35104d540e86db09f9386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecd0069e7f35104d540e86db09f9386">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update <em>this</em> using range from <em>that</em>. </p>
<p>Source object is not invalidated but using it in parallel with <em>this</em> is undefined behaviour. </p>

</div>
</div>
<a id="abf3ba49ab1c2264331c23f8a44789cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3ba49ab1c2264331c23f8a44789cc6">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::print </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each argument, invoke <a class="el" href="classsal_1_1memory__writer__t.html#a69298c3801bf229b75b2d86a9cfa1f60" title="Copy NUL-terminated string content to this memory area. ">operator&lt;&lt;()</a> ie add formatted content to <em>this</em>. </p>
<p>When upper limit is reached, no content is copied but write pointer is still moved forward.</p>
<p>This class has inserter operator only for NUL-terminated const char * and single characters. Header file <a class="el" href="format_8hpp.html" title="Memory range formatted content writer. ">sal/format.hpp</a> has more specialisations for different POD types and std::string. By providing inserter specialisations for user defined types, those will be able <a class="el" href="classsal_1_1memory__writer__t.html#abf3ba49ab1c2264331c23f8a44789cc6" title="For each argument, invoke operator&lt;&lt;() ie add formatted content to this. ">print()</a> as well. </p>

</div>
</div>
<a id="add643e53924452e1dd0ef3bd22075053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add643e53924452e1dd0ef3bd22075053">&#9670;&nbsp;</a></span>safe_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t sal::memory_writer_t::safe_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes between writer pointer and upper limit. </p>
<p>In <a class="el" href="classsal_1_1memory__writer__t.html#a435afa3f70f9f9378d95a2973e61e432" title="Return true if write pointer has moved past upper limit. ">bad()</a> state it returns 0. </p>

</div>
</div>
<a id="a86aa39a54d7f8072ca946f59e9015614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86aa39a54d7f8072ca946f59e9015614">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t sal::memory_writer_t::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes between writer pointer and upper limit. </p>
<p>While in <a class="el" href="classsal_1_1memory__writer__t.html#a435afa3f70f9f9378d95a2973e61e432" title="Return true if write pointer has moved past upper limit. ">bad()</a> state, this method's returned value is undefined. </p>

</div>
</div>
<a id="a7d043e291505ccb4416a47cc8b09deb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d043e291505ccb4416a47cc8b09deb9">&#9670;&nbsp;</a></span>skip_until()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::skip_until </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move write pointer towards upper limit until character <em>ch</em> is found. </p>
<p>If there is no <em>ch</em> before <a class="el" href="classsal_1_1memory__writer__t.html#ac0481edfdc6a6a1bb4a35721aa6d40e1" title="Return upper limit pointer (one byte past actual fillable memory area) ">end()</a>, search stops there. </p>

</div>
</div>
<a id="a94fba5b3bc60e76d5215ffcec407d2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fba5b3bc60e76d5215ffcec407d2a2">&#9670;&nbsp;</a></span>write() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::write </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy memory content of <em>v</em> to <em>this</em> memory writer area and move write pointer towards upper limit by <code>sizeof(v)</code>. </p>
<p>If write pointer is already past upper limit, no content is actually copied but pointer is still moved forward. </p>

</div>
</div>
<a id="a3af46b74477ba689ca7eeed97078a7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af46b74477ba689ca7eeed97078a7ff">&#9670;&nbsp;</a></span>write() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::write </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy memory content of continuous memory area [<em>begin</em>, <em>end</em>) to <em>this</em> memory writer area and move write pointer towards upper limit by number of bytes between specified range. </p>
<p>If write pointer is already past upper limit, no content is actually copied but pointer is still moved forward. </p>

</div>
</div>
<a id="af14a85578dbfb8ea5a6919ecf9be9ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14a85578dbfb8ea5a6919ecf9be9ad8">&#9670;&nbsp;</a></span>write() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a>&amp; sal::memory_writer_t::write </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write [<em>array</em>, <em>array</em> + <em>N</em>) to <em>this</em> memory area. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsal_1_1memory__writer__t.html#a3af46b74477ba689ca7eeed97078a7ff" title="Copy memory content of continuous memory area [begin, end) to this memory writer area and move write ...">write(const T *, const T *)</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>sal</b></li><li class="navelem"><a class="el" href="classsal_1_1memory__writer__t.html">memory_writer_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
